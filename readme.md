# Harbor

Unified (mostly) type-safe interface for Elm Ports.

## Why does this exist?

[Elm Ports](https://guide.elm-lang.org/interop/ports.html) are not that great when it comes to reusability, composibility and type-safety outside of Elm.

Most folks end up writing one new port for everytime they need to talk to a process outside Elm, or everytime a process needs to talk to Elm.

What if you could simply have one interface to talk and one to listen?

## How does this work?

(Note: the codegen parts of this library are not yet ready.)

**1. You define the types of incoming messages and outgoing messages in Harbor.elm.**

```elm
-- Harbor.elm
type PortOutMsg =
  LogToConsole String
  ReadFile FileName -- type Filename = FilePath String
  StoreUserInLocal User -- type alias User = { id: String, name: String}
  GetUserFromLocal String

-- note how all the PortInMsg types are just wrappers around String. That's required because you are going to JSON.stringify all data coming from outside Elm.
type PortInMsg =
  ReceiveFileContents String
  ReceiveUserFromLocal String
  Unknown String
```

**2. Define how you want to handle the data going out.**

```elm
sendHandler : PortOutMsg -> Encode.Value
sendHandler msg =
  case msg of
    LogToConsole str -> Encode.string str
    ReadFile (FilePath path) -> Encode.string path
    StoreUserInLocal usr -> Encode.object [
      ("id", Encode.string usr.id),
      ("name", Encode.string usr.name)
    ]
    GetUserFromLocal str -> Encode.string str
```

**3. Run the generator** (TODO)

This will generate two files:

```
- HarborGenerated.elm
- HarborGenerated.js
```

**4. Import the subscription and types to get started!**

_To listen to incoming messages:_

In your `Main.elm`'s subscription, you will include the subscription generated by Harbor:

```elm
import Harbor as H
import HarborGenerated as H

subscriptions = Sub.batch [
  ... -- existing ones
  , H.harborSubscription
]
```

And in your Main `Msg`, you can add a simple `PortIn`:

```elm
-- Main.elm

type Msg =
  ... -- existing Msgs
  | PortIn H.PortInMsg

-- handle them in your update function
update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    -- all your existing stuff
    PortIn portInMsg ->
      case portInMsg of
        H.ReceiveFileContents contentsString -> ... -- typically decode the value
        H.ReceiveUserFromLocal userString -> ... -- Decode.decodeString userDecoder userString
        H.Unknown str -> ...
```

_To send messages to outside processes:_

Just use the `send` helper along with your own `PortOutMsg` types:

```elm
import Harbor as H
import HarborGenerated as H

update msg model =
  case msg of
    ... -> (model, H.send <| H.ReadFile (FilePath "./src/Main.elm"))
```

In your Javascript file, you can send and subscribe safely by using enumerated types that are generated by Harbor:

```js
// index.js
const { MsgToElm, MsgFromElm } = require('./src/HarborGenerated.js');
const { Elm } = require('./src/elm-compiled.js');
const app = Elm.Main.init({ flags: null });

// to send
app.ports.toElm.send([MsgToElm.ReceiveFileContents, JSON.stringify(fileData)]);

// to receive
app.ports.fromElm.subscribe((msg, data) => {
  switch (msg) {
    case MsgFromElm.LogToConsole:
      console.log(data);
      break;
    case MsgFromElm.ReadFile:
      const contents = readFile(data);
      app.ports.toElm.send([
        MsgToElm.ReceiveFileContents,
        JSON.stringify(contents),
      ]);
      break;
    // .. and so on
    default:
      break;
  }
});
```
