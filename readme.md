# Harbor

Unified (mostly) type-safe interface for Elm Ports.

## Why does this exist?

[Elm Ports](https://guide.elm-lang.org/interop/ports.html) are not that great when it comes to reusability, composibility and type-safety outside of Elm.

Most folks end up writing one new port for everytime they need to talk to a process outside Elm, or everytime a process needs to talk to Elm.

What if you could simply have one interface to talk and one to listen?

## How does this work?

(Note: the codegen parts of this library are not yet ready.)

**1. You define the types of incoming messages and outgoing messages in Harbor.elm.**

```elm
-- Harbor.elm
type PortOutMsg =
  LogToConsole String
  ReadFile FileName -- type Filename = FilePath String
  StoreUserInLocal User -- type alias User = { id: String, name: String}
  GetUserFromLocal String

type PortInMsg
    = ReceiveString String
    | ReceiveBool Bool
    | ReceiveUser (Maybe User)
    | Unknown

```

**2. Define how you want to handle the data going out (sendHandler) and coming in (receiveHandler).**

```elm
-- you have to convert all the data going out into a JSON value using encoders.
sendHandler : PortOutMsg -> Encode.Value
sendHandler msg =
  case msg of
    LogToConsole str -> Encode.string str
    ReadFile (FilePath path) -> Encode.string path
    StoreUserInLocal usr -> Encode.object [
      ("id", Encode.string usr.id),
      ("name", Encode.string usr.name)
    ]
    GetUserFromLocal str -> Encode.string str


-- you have to supply decoders to convert incoming values
-- into values that the types of PortInMsg understand
receiveHandler : ( String, Encode.Value ) -> PortInMsg
receiveHandler ( key, val ) =
    let
        jsonString =
            Encode.encode 0 val
    in
    case key of
        "ReceiveString" ->
            ReceiveString <|
                Decode.decodeString Decode.string jsonString
                    |> Result.toMaybe
                    |> Maybe.withDefault ""

        "ReceiveBool" ->
            ReceiveBool <|
                Decode.decodeString Decode.bool jsonString
                    |> Result.toMaybe
                    |> Maybe.withDefault False

        "ReceiveUser" ->
            ReceiveUser <|
                Decode.decodeString
                    (Decode.map2 (\id name -> { id = id, name = name })
                        (Decode.field "id" Decode.string)
                        (Decode.field "name" Decode.string)
                    )
                    jsonString
                    |> Result.toMaybe

        _ ->
            Unknown

```

**3. Run the generator**

(TODO)

This will generate two files:

```
- HarborGenerated.elm
- HarborGenerated.js
```

**4. Import the subscription and types to get started!**

_To listen to incoming messages:_

In your `Main.elm`'s subscription, you will include the subscription generated by Harbor:

```elm
import Harbor as H
import HarborGenerated as H

subscriptions = Sub.batch [
  ... -- existing ones
  , H.harborSubscription
]
```

And in your Main `Msg`, you can add a simple `PortIn`:

```elm
-- Main.elm

type Msg =
  ... -- existing Msgs
  | PortIn H.PortInMsg

-- handle them in your update function
update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    -- all your existing stuff
    PortIn portInMsg ->
      case portInMsg of
        H.ReceiveString str -> ... 
        H.ReceiveBool bool -> ... -- Decode.decodeString userDecoder userString
        H.ReceiveUser user -> ...
        H.Unknown -> ...
```

_To send messages to outside processes:_

Just use the `send` helper along with your own `PortOutMsg` types:

```elm
import Harbor as H
import HarborGenerated as H

update msg model =
  case msg of
    ... -> (model, H.send <| H.ReadFile (FilePath "./src/Main.elm"))
```

In your Javascript file, you can send and subscribe safely by using enumerated types that are generated by Harbor:

```js
// index.js
const { MsgToElm, MsgFromElm } = require('./src/HarborGenerated.js');
const { Elm } = require('./src/elm-compiled.js');
const app = Elm.Main.init({ flags: null });

// to send
app.ports.toElm.send([MsgToElm.ReceiveString, "something"]);
app.ports.toElm.send([MsgToElm.ReceiveBool, true]);

// to receive
app.ports.fromElm.subscribe((msg, data) => {
  switch (msg) {
    case MsgFromElm.LogToConsole:
      console.log(data);
      break;
    case MsgFromElm.ReadFile:
      const contents = readFile(data);
      app.ports.toElm.send([
        MsgToElm.ReceiveUser,
        data,
      ]);
      break;
    // .. and so on
    default:
      break;
  }
});
```
